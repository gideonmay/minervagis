
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Job manager class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Jobs/Manager.h"
#include "Usul/Errors/Assert.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Strings/Format.h"
#include "Usul/Threads/Safe.h"
#include "Usul/Threads/ThreadId.h"

#include "boost/bind.hpp"
#include "boost/thread.hpp"

#include <algorithm>
#include <ctime>

using namespace Usul::Jobs;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data members.
//
///////////////////////////////////////////////////////////////////////////////

Manager *Manager::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Manager ( const std::string &name, unsigned int poolSize ) :
  _mutex     (),
  _pool      ( name, poolSize ),
  _log       ( 0x0 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::~Manager()
{
  Usul::Functions::safeCall ( boost::bind ( &Manager::_destroy, this ), "3016860991" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton construction.
//
///////////////////////////////////////////////////////////////////////////////

Manager &Manager::instance()
{
  if ( 0x0 == _instance )
  {
    Manager::init ( "Usul::Jobs::Manager::instance()", boost::thread::hardware_concurrency() );
  }
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton construction with given size.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::init ( const std::string &name, unsigned int poolSize )
{
  Manager::destroy();
  _instance = new Manager ( name, poolSize );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton destruction.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::destroy()
{
  delete _instance;
  _instance = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy the members.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::_destroy()
{
  Guard guard ( this );
  _log = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add a job to the container.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::addJob ( Job::RefPtr job )
{
  if ( true == job.valid() )
  {
    job->_setId ( this->nextJobId() );

    this->_logEvent ( "Adding job", job );
    {
      Guard guard ( this );
      _pool.addTask ( 
        job->priority(), 
        job->id(), 
        job->name(), 
        boost::bind ( &Job::_threadStarted, job ), 
        boost::bind ( &Job::_threadFinished, job ), 
        boost::bind ( &Job::_threadCancelled, job ), 
        boost::bind ( &Job::_threadError, job ) );
    }
    this->_logEvent ( "Done adding job", job );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Remove the queued job. Has no effect on running jobs.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::removeQueuedJob ( Job::RefPtr job )
{
  if ( true == job.valid() )
  {
    Usul::Threads::Pool::TaskHandle task ( job->priority(), job->id() );
    this->_logEvent ( "Removing queued job", job );
    {
      Guard guard ( this );
      _pool.removeQueuedTask ( task );
    }
    this->_logEvent ( "Done removing queued job", job );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the mutex. Use with caution.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Mutex &Manager::mutex() const
{
  return _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the next job id. This will also increment the internal counter.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long Manager::nextJobId()
{
  Guard guard ( this );
  return _pool.nextTaskId();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Wait for all jobs to complete.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::wait()
{
  this->_logEvent ( "Waiting for tasks... " );
  {
    Guard guard ( this );
    _pool.waitForTasks();
  }
  this->_logEvent ( "Done waiting for tasks" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the thread pool size.
//
///////////////////////////////////////////////////////////////////////////////

std::size_t Manager::poolSize() const
{
  Guard guard ( this );
  return _pool.numThreads();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Cancel all threads and pending tasks in the pool, which cancels the jobs.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::cancel()
{
  this->_logEvent ( "Canceling thread pool..." );
  {
    Guard guard ( this );
    _pool.cancel();
  }
  this->_logEvent ( "Done canceling thread pool" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Cancel the given job.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::cancel ( Job::RefPtr job )
{
  if ( true == job.valid() )
  {
    this->removeQueuedJob ( job );
    this->_logEvent ( "Canceling job", job );
    job->cancel();
    this->_logEvent ( "Done canceling job", job );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear any jobs that are queued, but not running.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::clearQueuedJobs()
{
  // Clear all queued tasks.
  this->_logEvent ( "Clearing queued tasks" );
  {
    Guard guard ( this );
    _pool.clearQueuedTasks();
  }
  this->_logEvent ( "Done clearing queued tasks" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Number of jobs queued.
//
///////////////////////////////////////////////////////////////////////////////

std::size_t Manager::numJobsQueued() const
{
  Guard guard ( this );
  return _pool.numTasksQueued();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Number of jobs executing.
//
///////////////////////////////////////////////////////////////////////////////

std::size_t Manager::numJobsExecuting() const
{
  Guard guard ( this );
  return _pool.numTasksExecuting();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Number of jobs.
//
///////////////////////////////////////////////////////////////////////////////

std::size_t Manager::numJobs() const
{
  Guard guard ( this );
  return ( this->numJobsQueued() + this->numJobsExecuting() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the names of the executing jobs.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::executingNames ( Strings &names ) const
{
  Guard guard ( this );
  _pool.executingNames ( names );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the log.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::logSet ( LogPtr lp )
{
  Guard guard ( this );

  _log = lp;
  _pool.logSet ( lp );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the log.
//
///////////////////////////////////////////////////////////////////////////////

Manager::LogPtr Manager::logGet()
{
  Guard guard ( this );
  return LogPtr ( _log );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Log the event.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::_logEvent ( const std::string &s, Job::RefPtr job )
{
  LogPtr file ( this->logGet() );
  if ( ( false == s.empty() ) && ( true == file.valid() ) )
  {
    if ( true == job.valid() )
    {
      file->write ( Usul::Strings::format ( "clock: ", ::clock(), ", system thread: ", Usul::Threads::currentThreadId(), ", id: ", job->id(), ", priority: ", job->priority(), ", address: ", job.get(), ", manager: ", this, ", name: ", job->name(), ", event: ", s ) );
    }
    else
    {
      file->write ( Usul::Strings::format ( "clock: ", ::clock(), ", system thread: ", Usul::Threads::currentThreadId(), ", event: ", s ) );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  See if a higher-priority job is waiting.
//
///////////////////////////////////////////////////////////////////////////////

bool Manager::isHigherPriorityJobWaiting ( int priority ) const
{
  Guard guard ( this );
  return _pool.isHigherPriorityTaskWaiting ( priority );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the name.
//
///////////////////////////////////////////////////////////////////////////////

std::string Manager::name() const
{
  return _pool.name();
}
